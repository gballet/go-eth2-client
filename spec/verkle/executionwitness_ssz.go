// Code generated by fastssz. DO NOT EDIT.
// Hash: d7bb13eea2fdbff8ec3b8cdd403e7f3b00d6b8a5493504d19b7f8e02deb14e01
// Version: 0.1.3
package verkle

import (
	ssz "github.com/ferranbt/fastssz"
)

// HashTreeRoot ssz hashes the IPAProof object
func (i *IPAProof) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(i)
}

// HashTreeRootWith ssz hashes the IPAProof object with a hasher
func (i *IPAProof) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'CL'
	{
		subIndx := hh.Index()
		for _, i := range i.CL {
			hh.Append(i[:])
		}
		hh.Merkleize(subIndx)
	}

	// Field (1) 'CR'
	{
		subIndx := hh.Index()
		for _, i := range i.CR {
			hh.Append(i[:])
		}
		hh.Merkleize(subIndx)
	}

	// Field (2) 'FinalEvaluation'
	hh.PutBytes(i.FinalEvaluation[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the IPAProof object
func (i *IPAProof) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(i)
}

// HashTreeRoot ssz hashes the VerkleProof object
func (v *VerkleProof) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(v)
}

// HashTreeRootWith ssz hashes the VerkleProof object with a hasher
func (v *VerkleProof) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'OtherStems'
	{
		subIndx := hh.Index()
		num := uint64(len(v.OtherStems))
		if num > 65536 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range v.OtherStems {
			{
				elemIndx := hh.Index()
				byteLen := uint64(len(elem))
				if byteLen > 31 {
					err = ssz.ErrIncorrectListSize
					return
				}
				hh.AppendBytes32(elem)
				hh.MerkleizeWithMixin(elemIndx, byteLen, (31+31)/32)
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 65536)
	}

	// Field (1) 'DepthExtensionPresent'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(v.DepthExtensionPresent))
		if byteLen > 65536 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(v.DepthExtensionPresent)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (65536+31)/32)
	}

	// Field (2) 'CommitmentsByPath'
	{
		subIndx := hh.Index()
		num := uint64(len(v.CommitmentsByPath))
		if num > 65536 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range v.CommitmentsByPath {
			{
				elemIndx := hh.Index()
				byteLen := uint64(len(elem))
				if byteLen > 32 {
					err = ssz.ErrIncorrectListSize
					return
				}
				hh.AppendBytes32(elem)
				hh.MerkleizeWithMixin(elemIndx, byteLen, (32+31)/32)
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 65536)
	}

	// Field (3) 'D'
	hh.PutBytes(v.D[:])

	// Field (4) 'IPAProof'
	if v.IPAProof == nil {
		v.IPAProof = new(IPAProof)
	}
	if err = v.IPAProof.HashTreeRootWith(hh); err != nil {
		return
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the VerkleProof object
func (v *VerkleProof) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(v)
}


// HashTreeRoot ssz hashes the SuffixStateDiff object
func (s *SuffixStateDiff) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(s)
}

// HashTreeRootWith ssz hashes the SuffixStateDiff object with a hasher
func (s *SuffixStateDiff) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Suffix'
	hh.PutUint8(s.Suffix)

	// Field (1) 'CurrentValue'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(s.CurrentValue))
		if byteLen > 32 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(s.CurrentValue)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (32+31)/32)
	}

	// Field (2) 'NewValue'
	{
		elemIndx := hh.Index()
		byteLen := uint64(len(s.NewValue))
		if byteLen > 32 {
			err = ssz.ErrIncorrectListSize
			return
		}
		hh.Append(s.NewValue)
		hh.MerkleizeWithMixin(elemIndx, byteLen, (32+31)/32)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the SuffixStateDiff object
func (s *SuffixStateDiff) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(s)
}

// HashTreeRoot ssz hashes the StemStateDiff object
func (s *StemStateDiff) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(s)
}

// HashTreeRootWith ssz hashes the StemStateDiff object with a hasher
func (s *StemStateDiff) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Stem'
	hh.PutBytes(s.Stem[:])

	// Field (1) 'SuffixDiffs'
	{
		subIndx := hh.Index()
		num := uint64(len(s.SuffixDiffs))
		if num > 1073741824 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range s.SuffixDiffs {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 1073741824)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the StemStateDiff object
func (s *StemStateDiff) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(s)
}
